# Дървета. BST, AVL, Red-Black Tree
## Дърво
От дискретната математика знаем, че дървото е свързан ацикличен граф. Нека си представим, че не знаем какво е граф - ще го учим по-натам в курса. Дървото е структура от данни, чиито елементи са т.нар. възелчета. Те са свързани помежду си с ребра. Сега ще разгледаме няколко имплементации на дърветата..

### Първи начин: Чрез вектор от децата
```
template <class T>
struct Node
{
    T data;
    std::vector<Node*> children;
}
```
### Втори начин: Чрез вектор от децата и родител
```
template <class T>
struct Node
{
    T data;
    Node* parent;
    std::vector<Node*> children;
}
```
### Трети начин: Чрез списък на родителите
Този подход е полезен, когато върховете ни са номерирани със стойности в интервал [0, N]. Създаваме масив с N елемента, в който на всеки индекс i се намира номерът на родителя на възел с номер i. Кореновият елемент най-често се обозначава като родител сам на себе си (ако root елементът се номер 4, то parentArr[4] = 4) или на негово място се пише -1. Какви са предимствата на този начин? Можем да имплементираме каквото искаме дърво така.

### Четвърти начин: Чрез списък за пълно двоично дърво
Двоично дърво (Binary tree) наричаме дърво, за което всеки възел има най-много две деца (ляво и дясно). Празното дърво е двиочно. Всеки възел, чиито 2 наследника са двоични дървета, е двоично дърво.
### 
Пълно дърво (Complete tree) наричаме дърво, за което всяко ниво е запълнено изцяло, с изключение на последното, което е запълнено донякъде, но задължително отляво-надясно.

Можем да използваме следното представяне за пълно двоично дърво, чиито върхове са номерирани от 0 до N в реда на обхождане в широчина:
* Създаваме вектор, за който на индекс 0 стои коренът на дървото.
* За всеки елемент с номер i, неговите деца са записани на позиции 2i+1 (ляво дете) и 2i+2 (дясно дете).

(Пример за това представяне ще видим на темата за двоични пирамиди)

Други начини:
* Чрез представяния на граф спрямо първата дефиниция, която разгледахме, дървото е частен случай на граф. Следователно всяко от представянията за графи може да се използва, за да се зададе и структурата на дърво. Примери за това са:
*   Списък на ребрата
*   Списък на наследниците
*   Матрица на съседство
* Двоично наредено дърво (за търсене) - BST
Двоично наредено дърво е дърво, за което стойността на всеки възел е по-голяма от всички елементи в лявото му поддърво и е по-малка от всички елементи в дясното му поддърво.

Забележете, че не е достатъчно да сръвним възелът с неговите преки ляв и десен наследник, тъй като това не ни гарантира, че надолу в поддървото няма елемент, чупещ горното правило.

Името на BST идва от хубавото му свойство, че проверката дали елемент се съдържа в него е изключително проста. Сравняваме даденият елемент с кореновият елемент. Ако е по-малък, повтаряме за лавото поддърво. Ако е по-голям - за дясното. Правим го докато не открием търсеният елемент или не установим липсата му.

В дефиницията по-горе използвахме операциите "по-голямо" и "по-малко", но в реална имплементация не е задължително да сравняваме числови стойности. Най-често се използва двуместен предикат, който, ако е в сила - елементът трябва да бъде поставен в ляво от текущия, а ако не е - в дясно от текущия.

## Операции с BST

find:
* Average-Case - Theta(log(n))
* Worst-Case - Theta(n)

insert:
* Average-Case - Theta(log(n))
* Worst-Case - Theta(n)

erase:
* Average-Case - Theta(log(n))
* Worst-Case - Theta(n)

Важно е да забележим, че в най-лошия случай тези операции са линейни. Това се дължи на факта, че в случая говорим за обикновено BST. Едносвързан сортиран свързан списък също влиза в дефиницията на BST (така нареченото изродено BST), а търсенето в свързан списък, както знаем от предните теми, е линейно.

## Балансирано BST
Balance Factor - число, което оценява колко "балансиран" е всеки от върховете (дава оценка по зададен критерий). Чрез него можем да дефинираме изисквания за балансиране на дървото.

Дефинирайки balance factor за всеки един връх, можем да дадем оценка колко близко до желано състояние (наречено балансирано състояние) е дадено дърво. В балансирано дърво операциите са с логаритмична сложност в най-лошият случай.

Свойството "балансираност" не е задължително да бъде дефинирано чрез balance factor, но много често е удобно да се използва.

### Самобалансиращи се BST - AVL
Както името подсказва, самобалансиращите се дървета сами гарантират своята балансираност. Конкретен пример за това е AVL дървото (кръстено на своите създатели), което използва следният balance factor за оценка:

BalanceFactor(n) = Height(n->right) - Height(n->left)

Правило за балансираност: за всеки връх n, |BalanceFactor(n)| <= 1

Процесът по балансиране се случва автоматично при добавяне и премахване на елемент. В случаят на AVL дървета това се извършва чрез операциите за лява и дясна ротация.

### Самобалансиращи се BST - Red-Black
Балансираността тук не е дефинирана чрез balance factor, а чрез редица свойства, които винаги трябва да са в сила (така наречения инвариант).

Инвариантът на Red-Black Tree гласи:

Всеки възел има цвят - черен или червен

Всеки NIL възел (празен възел) е черен

Червен възел не може да има червен наследник

Всеки път от произволен връх до всички NIL елементи в поддървото му трябва да преминава през равен брой черни върхове

Коренът винаги е черен (не е задължително, но често се прилага)

Следствие: Ако произволен връх има точно 1 наследник, то той е червен
Балансирането отново се извършва по време на самите операции за добавяне и премахване. Отново се разчита на принципа на ротациите, но също така има случаи в които вместо ротация се предпочита обикновенно преоцветяване на върховете.

## Дървета в STL
В STL разполагаме със следните колекции, които работят именно чрез Red-Black дървета:
* std::set<T> - множество от елементи без повторение
* std::multiset<T> - множество от елементи с повторение
* std::map<K,V> - множество от двойки ключ-стойност
* std::multi-map<K,V> - множество от двойки ключ-стойност
